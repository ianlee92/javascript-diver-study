4장부터 7장까지의 키 포인트 + 개인적인 생각 정리

# 💭 자바스크립트의 정신

에러 발생을 최대한 줄이는 것.

## 4장 변수

### Hoisting

자바스크립트는 모든 선언문을 실행한 후에 런타임으로 진입한다. 아래 키워드로 선언된 변수는 모두 호이스팅의 대상이 된다.

- `var`, `let`, `const`, `function`, `function *`, `class`

이런 특성 때문에, 선언 전인 변수를 참조할 때 Reference error가 발생하지 않는다. 다만 해당 변수의 값이 `undefined` 상태라고만 뜬다.

선언과 동시에 할당하는 구문이 있다면 아래 순서대로 실행된다.

1. 변수 선언
2. 런타임 진입
3. 변수 할당

### 변수 재할당

C/C++과 달리 특이한 점은, 변수가 재할당 될 때 아예 새로운 메모리를 사용한다는 점이다.
GC가 내장되어 있어서 더이상 사용하지 않는 메모리 공간을 알아서 정리해준다.

- Unmanaged language: GC가 없는 언어.
  - 개발자가 주도하여 메모리 관리를 할 수 있으나 치명적 오류가 있을 수 있다.
- Managed language: GC가 있는 언어.
  - 개발자에 관계 없기 때문에 일정한 생산성을 유지할 수 있으나 성능이 살짝 떨어진다.

## 5장 표현식과 문

- 리터럴은 사람이 이해하기 편한 표현 방법이기 때문에 machine code와 대치되는 개념이다.
- 할당문 역시 expression의 한 종류이다. 할당한 값이 결과로 계산되어 나오기 때문이다.
- statement의 끝을 의미하는 세미콜론은 자바스크립트 엔진이 자동으로 삽입해준다. (지금까지는 VScode처럼 에디터가 하는 일인줄 알았다.)

## 6장 데이터 타입

### Primitive Types

- 자바스크립트의 primitive type은 조금 색다른점이 있다.
- primitive type: 객체가 아니면서 메서드도 갖지 않는 자료형.

1. **number**: 모든 숫자는 64비트 실수로 처리한다.
   - 미리 정의되어있는 값: `Infinity`, `-Infinity`, `NaN`
2. **string**
3. **boolean**
4. **undefined**: 자바스크립트가 `var` 변수를 초기화하기 위한 용도로 만들어진 것으로, 개발자가 직접 할당하는 것을 권장하지 않는다.
5. **null**: "값이 없음"을 의미. 개발자는 `undefined`보다는 `null`을 직접 할당해주는게 적절하다.
6. **symbol**

이상한 점은 MDN에서는 5번 null 대신 [**bigint** 가 원시 타입 중 하나라고 소개](https://developer.mozilla.org/ko/docs/Glossary/Primitive)하고 있다는 점이다.

### 자바스크립트에서 타입의 주인

- C/C++, Java 등 static type language에서는 타입의 주인이 변수이다.
  - 한번 변수의 타입을 지정하면 그 변수는 영원히 해당 타입 값만 할당받을 수 있다.
- 자바스크립트에서 타입의 주인은 **값**이다.
  - 그리고 그 값이 변수에 할당되기 때문에, 하나의 변수는 여러가지 타입의 값을 담을 수 있다.
  - 이런 사실 때문에, `자바스크립트에서는 변수 사용을 최소화하는 것이 권장된다.`
    - 변수 하나가 타입 여러개를 가지다보면 에러가 발생할 확률이 높아지기 때문이다. 디버깅도 힘들어진다.

## 7장 연산자

### Implicit coercion

- 에러를 최소화하기 위해 자바스크립트에서는 암묵적 타입 변환을 지원한다.
- 그동안 개발하며 별 생각없이 썼던 `+` 연산자를 사용할 때에도 사실은 암묵적 타입 변환이 일어나고 있었다.
  - e.g) `const iAmNumber = +'300';` => 이렇게 하면 변수에 number 타입 값 300이 할당된다.

### 비교 연산자

- 동등 비교 `==`: 값이 같은지 확인
- 일치 비교 `===`: 값이 같고 타입도 같은지 확인
- 단, `NaN`인지 확인하려면 비교 연산자를 사용하지 말고 `isNaN()` 함수를 사용해야 한다.
  - 데이터베이스 시간에 배웠던 내용 중에 null 값이 또다른 null 값과 같지 않은 이유와 비슷한 이유에서 이렇게 만든 것이라고 추측해본다.
