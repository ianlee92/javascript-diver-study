- **들어가며**
    - 프로그래머의 역할은 무엇일까?

        요구사항을 기반으로 문제 해결 방안을 고안하고, 코드로 구현하는 것!

        그리고 구현 코드가 컴퓨터 내부에서 어떻게 동작할 것인지 예측 가능하고, 명확히 설명할 수 있어야 한다.

        여기에는 프로그래밍 언어의 기본 개념과 동작 원리를 정확히 이해하는 것이 뒷바침되야 한다.

    - **기본 개념**은 문맥에 맞는 정확한 용어를 사용하게 해주고, 명확한 의사소통이 가능해진다.

        개념을 이해한다는 것은 용어를 정확히 이해하고 설명할 수 있다는 것이고, 개발자 간 의사소통 뿐만 아니라 서적이나 매뉴얼 등 문서를 이해하도록 돕고, 프로그래밍 언어를 학습하는 데 중요한 역할을 한다.

    - **동작 원리를 이해**하면 코드의 동작이 예측 가능하며 코드 독해의 원천이 된다.

    - 학습 순서
        1. 이해 : 기본 개념과 동작 원리 이해 (용어 및 개념, 문법, 컴퓨팅 사고)
        2. 숙달 : 의도적 연습(예제), API, 프레임워크 및 라이브러리
        3. 경험 : 프로젝트를 통해 가상 경험

    → 먼저 전반적인 이해를 하고, 예제 등을 테스트하고, 클론 코딩 등부터 실제 프로젝트까지 경험

    → 위 과정을 순환적으로 여러 번 반복해서 학습. 코드 구현 능력을 갖추기 위한 연습 중요!

    → [**의도적인 연습**](http://coachround.com/deliberate-practice/) : 자신의 능력을 살짝 넘어서는 도전을 지속적으로 시도하는 것.

- **01장: 프로그래밍**
    - 프로그래밍이란? 프로그래밍 언어 사용해 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션

        컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션. 컴퓨터 관점에서 사고해야 한다.

        이를 위해 먼저 요구사항을 명확히 이해한 후 문제 해결 방안을 정의할 필요가 있다.

    - **프로그래밍 언어** : 컴퓨터와 대화(명령)에 사용되는 일종의 표현 수단. 약속된 형태의 인공어

        **자연어**: 사람이 이해할 수 있는 언어

        **기계어**: 컴퓨터가 이해할 수 있는 언어, 프로그래머는 기계어로 컴퓨터에 명령을 전달.

        **컴파일러 (혹은 인터프리터)** : 프로그래밍 언어로 작성한 프로그램을 컴퓨터가 이해할 수 있는 기계어로 변환하는 일종의 번역기

    - **프로그래밍에서의 구문과 의미** : 프로그래밍 언어는 구문과 의미의 조합으로 표현된다.

        언어처럼 문법에 맞는 문장을 구성하는 것 뿐만 아니라 문맥에 있는 의미도 중요하다.

        → 변수를 통해 값을 저장하고 참조하며, 

        → 연산자로 값을 연산 및 평가, 

        → 조건문과 반복문로 흐름제어를 하여 코드의 실행 순서를 제어,

        → 함수로 재사용 가능한 문의 집합을 만들며,

        → 객체, 배열 등으로 자료를 구조화한다.

        결국 프로그래밍은 요구사항의 집합을 분석해 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것.

- **02장: 자바스크립트란?**
    - 자바스크립트의 탄생 : 1995년 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어를 도입하기 위해 브렌던 아이크가 자바스크립트를 개발

    - 자바스크립트의 표준화 : 마이크로소프트에서 출시한 자바스크립의 파생 버전 "JScript"는 자바스크립트와 적당히 호환되었으나, 브라우저에 따라 크로스 브라우징 이슈 발생

        → 그래서 **ECMAScript** 탄생! ES6에서는 let/const 키워드, 화살표 함수, 클래스, 모듈 등 기능 대거 도입.

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5f9cd6f6-30b6-4d50-bc82-96866dfa5ede/.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5f9cd6f6-30b6-4d50-bc82-96866dfa5ede/.png)

        → 2020년도에 ES11(ECMAScript 2020)까지 나왔다. ([ES 버전 별 특징 간단하게 살펴보기](https://medium.com/sjk5766/ecma-script-es-%EC%A0%95%EB%A6%AC%EC%99%80-%EB%B2%84%EC%A0%84%EB%B3%84-%ED%8A%B9%EC%A7%95-77715f696dcb))

    - 자바스크립트 성장의 역사
        - **Ajax (Asynchronous JavaScript and XML)** : 1999년에 등장한 자바스크립트를 이용하여 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능

            → 웹페이지에서 변경할 필요 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만 전송 받아 변경해야 하는 부분만 한정적으로 렌더링 하는 방식

            (대표적으로 [Google Maps](https://www.google.com/maps), 자바스크립트와 Ajax를 기반으로 동작)

        - **jQuery** : 2006년에 등장한 DOM(Document Object Model)을 더 쉽게 제어하고 크로스 브라우징 이슈를 어느 정도 해결해주는 자바스크립트 라이브러리.
        - **V8 자바스크립트 엔진** : 2008년에 등장한 구글의 자바스크립트 엔진.

            웹 브라우저를 만드는 데 기반을 제공하는 오픈 소스 자바스크립트 엔진이며, 자바스크립트를 바이트코드(bytecode)로 컴파일하고 실행하는 방식을 사용한다. ([위키백과 더보기](https://ko.wikipedia.org/wiki/V8_(%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_%EC%97%94%EC%A7%84)))

        - **Node.js** : 2009년 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경.

            브라우저의 자바스크립트 엔진에서만 동작하던 것을 브라우저 이외의 환경에서도 동작할 수 있게 자바스크립트 엔진을 독립시킨 자바스크립트 실행 환경.

            서바 사이드 어플 개발에 주로 사용되며, 이에 필요한 모듈, 파일 시스템, HTTP 등 내장 API 제공.

        - **SPA 프레임워크** : [CBD(Component based development)](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8_%EA%B8%B0%EB%B0%98_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B3%B5%ED%95%99) 방법론을 기반으로 [SPA(Single Page Application)](https://ko.wikipedia.org/wiki/%EC%8B%B1%EA%B8%80_%ED%8E%98%EC%9D%B4%EC%A7%80_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98)이 대중화되었고, Angular, React, Vue.js, Svelte 등 다양한 SPA 프레임워크/라이브러리 등장

    - 자바스크립트와 ECMAScript : ECMAScript는 자바스크립트의 표준 사양인 ECMA-262를 지칭, 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 내장 객체 등 핵심 문법을 규정한다.

        자바스크립트는 프로그래밍 언어로서 기본 뼈대를 이루는 ECMAScript와 [브라우저가 별도 지원하는 클라이언트 사이드 Web API](https://developer.mozilla.org/ko/docs/Web/API)(W3C에서 별도 사양으로 관리)를 아우르는 개념이다.

    - 자바스크립트의 특징 : HTML, CSS와 함께 웹을 구성하는 요소, 웹 브라우저에서 동작하는 유일한 프로그래밍 언어이다. 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어. (대부분 모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합하여 사용)

        → 자바스크립트는 런타임에 컴파일되며, 실행 파일 생성되지 않고, 인터프리터 도움 없이 실행될 수 없기 때문에 일반적으로 인터프리터 언어로 구분한다.

    - [ES6 브라우저 지원 현황](http://kangax.github.io/compat-table/es6/)

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/efbd9272-5744-45bf-9083-31d9818fd336/ECMAScript_6_compatibility_table.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/efbd9272-5744-45bf-9083-31d9818fd336/ECMAScript_6_compatibility_table.jpg)

        (구형 브라우저는 Babel과 같은 트랜스파일러 활용해 ES5 이하 사양으로 다운그레이드 가능)

- **03장: 자바스크립트 개발 환경과 실행 방법**
    - 자바스크립트 실행 환경 : 자바스크립트는 브라우저 환경 또는 Node.js 환경에서 실행 가능.
    - 웹 브라우저 : 여기선 [구글 크롬](https://www.google.com/intl/ko/chrome/) 사용.
        - 개발자 도구
        - 콘솔
        - 브라우저에서 자바스크립트 실행
        - 디버깅
    - Node.js
        - Node.js와 npm 소개 : npm(node package manager)은 자바스크립트 패키지 매니저.
        - [모듈화와 npm](https://poiemaweb.com/nodejs-npm) : Client-side JavaScript의 경우, script 태그를 사용하여 외부의 스크립트 파일을 가져올 수는 있지만, 파일마다 독립적인 파일 Scope를 갖지 않고 하나의 전역 객체(Global Object)에 바인딩되기 때문에, 전역변수가 중복되는 등의 문제가 발생할 수 있다.

            브라우저에서의 모듈 사용은 대부분의 브라우저가 ES6의 모듈을 지원하지 않고 있으므로 Browserify 또는 webpack과 같은 모듈 번들러를 사용하여야 한다.

        - [Node.js 설치](https://nodejs.org/ko/)
        - Node.js REPL
    - 비주얼 스튜디오 코드 : 많이 쓰는 코드 에디터
        - [비주얼 스튜디오 코드 설치](https://code.visualstudio.com/)
        - 내장 터미널
        - Code Runner 확장 플러그인 : vscode 내장 터미널에서 단축키로 소스코드 간단히 실행
        - Live Server 확장 플러그인 : 소스코드 수정할 때마다 브라우저에 자동 반영

- **04장: 변수**
    - **변수**란 무엇인가? 왜 필요한가?

        컴퓨터는 메모리 셀 단위로 데이터를 다루며, 메모리 셀 하나의 크기는 1바이트(8비트). 

        각 셀은 고유의 메모리 주소를 갖는다. 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 재사용하기 위해 변수를 제공한다. 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. (값을 저장하고 참조)

        ```jsx
        var result = 10 + 20;
        // 10+20은 연산을 통해 30이 되고, 메모리 공간에 저장된다. 그리고 변수 result로 참조
        ```

    - **식별자** : 변수 이름을 식별자라고도 한다.

        식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야 한다.

        즉, 식별자는 값이 아닌 메모리 주소를 기억하고 있고, 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 한다.

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7b53c91a-501a-4d82-a8c9-5e3d92002f5d/img.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7b53c91a-501a-4d82-a8c9-5e3d92002f5d/img.png)

    - **변수 선언** : 변수를 생성하는 것. 값을 저장하기 위한 메모리 공간을 확보하고(allocate), 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수 있게 준비하는 것이다. (var, let, const 키워드 사용. ES6에서 let, const 도입. var 단점은 15장에서 살펴본다.)

        ```jsx
        var score; // 변수 선언. 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.
        // 선언만 하는 경우 기본적으로 값 undefined(원시타입)이 암묵적으로 할당되어 초기화된다.
        ```

        - 자바스크립트의 모든 식별자는 자바스크립트 엔진의 [실행 컨텍스트](https://poiemaweb.com/js-execution-context)에 등록된다. (23장)

    - 변수 선언의 실행 시점과 변수 호이스팅

        ```jsx
        console.log(score); // undefined

        var score; // 변수 선언문
        ```

        → 변수 선언문보다 변수를 참조하는 코드가 앞에 있으나, 참조 에러가 발생하지 않고 undefiend가 출력된다. 그 이유는 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 **런타임이 아닌 그 이전 단계에서 먼저 실행**되기 때문이다. (실행 전 평가 과정)

        → 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있는 상관없이 다른 코드보다 먼저 실행한다. 이처럼 변수 선언문이 선두로 끌어 올려진 것처럼 동작하는 특징을 **변수 호이스팅**(variable hoisting)이라 한다.

    - 값의 할당 : 할당 연산자 '=' 사용. 우변 값을 좌변 변수에 할당.

        ```jsx
        var score; // 변수 선언, 선언과 동시에 undefined로 초기화
        score = 80; // 값의 할당, 엄밀히 말하면 undefined에서 80으로 재할당한 것

        var score = 80; // 변수 선언과 값의 할당
        ```

        → 선언과 할당을 나누어 표현하든 단축해서 표현하든 자바스크립트 엔진은 2개의 문으로 나누어 각각 실행한다. 주의할 점은 변수 선언은 소스코드가 순차적으로 실행되는 런타임 이전에 먼저 실행되지만, 값의 할당은 런타임에 실행된다.

    - 값의 재할당 : 변수에 저장된 값을 다른 값으로 변경하는 것.

        재할당할 수 없고 변수 값 변경 할 수 없으면 상수. 상수는 단 한 번만 할당할 수 있는 변수다.

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f4aacbb0-32a5-46c0-9189-d15051613067/memory.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f4aacbb0-32a5-46c0-9189-d15051613067/memory.jpg)

        → 재할당 이후 더이상 사용되지 않는 값 undefined와 80은 가비지 콜렉터가 메모리에서 자동 해제한다. 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어이다.

        (언매니지드 언어는 C언어처럼 개발자가 명시적으로 메모리 할당하고 해제)

    - 식별자 네이밍 규칙
        - 특수문자 제외한 문자, 숫자, '_', '$' 포함 가능
        - 특수문자 제외한 문자, 숫자, '_', '$' 로 시작해야 한다. 숫자로 시작 불가.
        - 예약어도 식별자로 사용 불가. (function, void, if, class, var, let 등)

        ```jsx
        // 사용 가능
        var person, $elem, _name, first_name, val1;
        var 이름, なまえ; // ES5부터 유니코드 문자도 허용, 권장되지는 않음

        // 사용 불가
        var first-name; // '-' 사용 불가
        var 1st, this; // 숫자 시작 불가, 예약어 사용 불가

        // 대소문자 구별
        var firstname, firstName, FIRSTNAME; // 모두 별개의 변수

        // 좋은 변수의 이름
        var x = 3; // x가 의미하는 바는 알 수 없다.
        var score = 100; // score는 점수를 의미. 이처럼 변수의 이름은 명확히 표현해야 한다.
        var elapsedTimeInDays; // 날짜 단위로 경과 시간을 의미. 명확하다.
        ```

        - 네이밍 컨벤션 : 자바스크립트에서는 일반적으로 변수나 함수에 카멜 케이스, 생성자 함수, 클래스 이름에는 파스칼 케이스를 사용한다.

        ```jsx
        // 카멜 케이스 (camelCase)
        var firstName;

        // 스네이크 케이스 (snake_case)
        var first_name;

        // 파스칼 케이스 (PascalCase)
        var FirstName;

        // 헝가리언 케이스 (typeHungarianCase)
        var strFirstName; // type + identifier
        var $elem = document.getElementById('myId'); // DOM 노드
        var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
        ```

- **05장: 표현식과 문**
    - **값** : 식(표현식 expression)이 평가(evaluate)되어 생성된 결과를 말한다. 여기서 평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.

        ```jsx
        10 + 20; // 10+20은 평가되어 숫자 값 30을 생성.

        var sum = 10 + 20; // 변수 sum에는 10+20이 평가되어 생성된 숫자 값 30이 할당된다.
        // sum이 기억하는 메모리 공간에 저장된 것은 10+20이 아닌 값 30이다.
        ```

    - **리터럴** : 사람이 이해 가능한 문자 또는 약속된 기호를 사용해 값 생성하는 표기법(notation)

        ```jsx
        3 // 숫자 리터럴 3
        // 숫자 리터럴 3을 코드에 기술하면 자바스크립트 엔진은 이를 평가해 숫자 값 3을 생성
        ```

        → 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성. 즉, 리터럴은 값을 생성하기 위해 미리 약속한 표기법이다.

    - **표현식** : 값으로 평가될 수 있는 문(statement). 표현식이 평가되면 새로운 값 생성하거나 기존 값을 참조한다.

        ```jsx
        var score = 100; // 100은 리터럴
        // 리터럴 100은 자바스크립트 엔진에 의해 평가되어 값을 생성하므로 그 자체로 표현식.

        var score = 50 + 50; // 50+50 도 평가되어 숫자 값 100을 생성하므로 표현식이다.

        score; // 100
        // 변수 식별자를 참조하면 변수 값으로 평가된다. 이와 같은 식별자 참조도 표현식이다.
        // 값으로 평가될 수 있는 문은 모두 표현식이다.

        // 리터럴 표현식
        10
        'Hello'

        // 식별자 표현식
        sum
        person.name
        arr[1]

        // 연산자 표현식
        10 + 20
        sum = 10
        sum !== 10

        // 함수/메서드 호출 표현식(선언이 이미 존재한다 가정)
        square()
        person.getName()
        ```

        → 표현식은 값으로 평가되고, 표현식과 표현식이 평가된 값은 동등한 관계(동차 equivalent).

        이는 문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 것을 의미.

    - **문(statement)** : 프로그램을 구성하는 기본 단위이자 최소 실행 단위. (명령문, 컴퓨터에 내리는 명령. 선언문, 할당문, 조건문, 반복문 등)

        → 문의 집합으로 이뤄진 것이 바로 프로그램.

        → 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍.

        → 문은 여러 토큰으로 구성. 

        **토큰** : 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소 (키워드, 식별자, 연산자, 리터럴, ';', '.' 등 특수 기호 모두가 토큰)

        ```jsx
        var x; // 변수 선언문

        x = 5; // 할당문

        function foo () {} // 함수 선언문

        if (x > 1) { console.log(x); } // 조건문

        for (var i = 0; i < 2; i++) { console.log(i); } // 반복문
        ```

    - 세미콜론과 세미콜론 자동 삽입 기능 : 세미콜론 ';' 은 문의 종료를 나타냄. 생략 가능.

        코드 블록 {...} 은 문의 종료를 의미하는 자체 종결성을 갖기 때문에 뒤에 ';' 붙이지 않음

        자바스크립트 엔진에는 세미콜론 **자동 삽입 기능(ASI : automatic semicolon insertion)**이 암묵적으로 수행되기 때문에 문의 끝에 세미콜론은 옵션이며, 생략 가능하다.

        ```jsx
        function foo () {
        	return
        		{}
        	// ASI 동작 결과 => return; {};
        	// 개발자 예측 => return {};
        }

        console.log(foo()); // undefined

        var bar = function () {}
        (function() {})();
        // ASI 동작 결과 => var bar = function () {}(function() {})();
        // 개발자 예측 => var bar = function () {};(function() {})();
        // TypeError: (intermediate value)( ... ) is not a function
        ```

        → 책에서도 세미콜론을 권장하고 있고 개발자의 의도를 명확히 표현하고 ASI가 의도와 다르게 동작하는 것을 방지하기 위해 세미콜론을 붙이도록 하자.

    - **표현식인 문과 표현식이 아닌 문** : 표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있다.

        ```jsx
        var x; // 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아님
        // 1, 2, 1+2, x=1+2 는 모두 표현식. x=1+2 는 완전한 문이기도 하다.

        x = 100; // 할당문은 그 자체가 표현식이지만 완전한 문. 즉, 할당문은 표현식인 문이다.

        // 표현식이 아닌 문은 값처럼 사용할 수 없다.
        var foo = var x; // SyntaxError: Unexpected token var

        // 표현식인 문은 값처럼 사용할 수 있다
        var foo = x = 100;
        console.log(foo); // 100
        // x = 100은 x 변수에 할당한 값 100으로 평가되고, foo 변수에는 100이 할당된다.
        // 이처럼 할당문을 값처럼 변수에 할당할 수 있다.
        ```

        표현식인 문은 값으로 평가될 수 있는 문, 표현식이 아닌 문은 값으로 평가될 수 없는 문.

        표현식 문과 표현식 아닌 문을 구별하는 가장 간단하고 명료한 방법? 변수에 할당해 보는 것.

        크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력. 

        이를 완료 값(completion value)이라 한다. 완료 값은 표현식의 평가 결과가 아니다.

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de075d76-29f7-4435-b20e-653a24e23f90/1.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de075d76-29f7-4435-b20e-653a24e23f90/1.png)

        표현식인 문을 실행하면 언제나 평가된 값을 반환.

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/37e9f997-03e1-4471-acc2-495b45618f15/2.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/37e9f997-03e1-4471-acc2-495b45618f15/2.png)

- **06장: 데이터 타입**
    - 데이터 타입 : 값의 종류. 자바스크립트의 모든 값은 데이터 타입을 갖는다.

        자바스크립트(ES6)는 **7개의 데이터 타입**을 제공한다. 

        크게는 **원시타입**(숫자,문자열,boolean,undefined,null,symbol)과 **객체타입**으로 분류.

    - **숫자 타입** : 자바스크립트는 ECMAScript 사양에 따라 숫자 타입의 값은 [배정밀도 64비트 부동소수점 형식](https://hbsowo58.tistory.com/460)을 따르며, 모든 수를 실수로 처리한다. 정수 타입은 별도로 존재하지 않는다.

        ```jsx
        // 정수, 실수, 2진수, 8진수, 16진수 리터럴은 
        // 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다.
        var integer = 10;
        var double = 10.12;
        var negative = -20;

        // 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않음
        // 이들 값을 참조하면 모두 10진수로 해석된다.
        var binary = 0b01000001; // 2진수
        var octal = 0o101; // 8진수
        var hex = 0x41; // 16진수

        // 표기법만 다를 뿐 모두 같은 값
        console.log(binary); // 65
        console.log(octal); // 65
        console.log(hex); // 65
        console.log(binary === octal); // true
        console.log(octal === hex); // true

        // 숫자 타입은 모두 실수로 처리된다
        console.log(1 === 1.0); // true
        console.log(4 / 2); // 2
        console.log(3 / 2); // 1.5

        // 숫자 타입의 세 가지 특별한 값 (Infinity, -Infinity, NaN : not-a-number)
        console.log(10 / 0); // Infinity
        console.log(10 / -0); // -Infinity
        console.log(1 * 'String'); // NaN, 대소문자 구별하므로 주의 필요
        ```

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cfdcc9a1-2c1b-43c5-a8a3-755fbd914353/11.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cfdcc9a1-2c1b-43c5-a8a3-755fbd914353/11.png)

        → 모든 숫자 타입은 실수로 처리되어 발생하는 문제. 필요하면 아래처럼 처리할 것 같다.

    - **문자열 타입** : 텍스트 데이터 나타내는 데 사용. UTF-16의 집합.

        작은따옴표(' '), 큰따옴표(" "), 백틱(` `)으로 텍스트를 감싸서 사용. 일반적으로 작은따옴표(' ') 사용.

        자바스크립트의 문자열은 원시 타입, 변경 불가능한 값(immutable value)이다.

        ```jsx
        var string;
        string = '문자열';
        string = "문자열";
        string = `문자열`;

        string = '작은따옴표로 감싼 문자열 내의 "큰따옴표"는 문자열로 인식.';
        string = "큰따옴표로 감싼 문자열 내의 '작은따옴표'는 문자열로 인식.";

        // 따옴표로 감싸지 않은 hello를 식별자로 인식한다.
        var string = hello; // ReferenceError: hello is not defined
        ```

    - **템플릿 리터럴** : ES6부터 도입된 새로운 문자열 표기법, 런타임에 일반 문자열로 변환 처리.

        ```jsx
        // 백틱을 사용해 표현
        var template = `Template literal`;
        console.log(template); // Template literal
        ```

        - 멀티라인 문자열 : 일반 문자열 내에서 줄바꿈 등 공백 표현하려면 백슬래시( \ )로 시작하는 이스케이프 시퀀스(escape sequence)를 사용해야 한다.

            ```jsx
            // 줄바꿈과 들여쓰기 적용된 HTML 문자열은 이스케이프 시퀀스 사용해 작성
            var template = '<ul>\n\t<li><a href="#">Home</a></li>\n</ul>';
            console.log(template);

            // 출력 결과
            <ul>
            	<li><a href="#">Home</a></li>
            </ul>

            // 템플릿 리터럴 내에서는 이스케이프 시퀀스 사용하지 않고도 줄바꿈 허용
            // 모든 공백도 있는 그대로 적용
            var template = `<ul>
            	<li><a href="#">Home</a></li>
            </ul>`;
            // 출력 결과는 위와 동일
            ```

        - 표현식 삽입 : 문자열은 연산자 (+) 사용해 연결할 수 있다.

            피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

            ```jsx
            var first = 'John';
            var last = 'Lee';

            // ES5 : 문자열 연결
            console.log('My name is ' + first + ' ' + last + '.'); // My name is John Lee.

            // ES6 : 표현식 삽입, 템플릿 리터럴 내에서만 사용 가능.
            console.log(`My name is ${first} ${last}.`); // My name is John Lee.
            ```

    - **불리언 타입** : true와 false. 조건문에서 자주 사용.

    - **undefined 타입** : var로 선언한 변수는 암묵적으로 undefined로 초기화된다.

        자바스크립트 엔진이 변수를 초기화할 때 사용, 개발자가 의도적으로 undefined를 사용하는 것은 본래 취지에 어긋나고 혼란을 줄 수 있으므로 권장되지 않는다. 

        → 개발자가 변수에 값이 없다는 것을 명시하고 싶다면 null을 할당.

    - **null 타입** : 변수에 값이 없다는 것을 의도적으로 명시할 때 사용. 변수에 null을 할당하면 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미.

        (자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행)

    - **심벌 타입** : ES6에서 추가된 7번째 타입. 다른 값과 중복되지 않는 유일무이한 값.

        → 주로 객체의 유일한 프로퍼티 키를 만들기 위해 사용. (자세한 내용은 33장에서)

    - **객체 타입** : 자바스크립트는 객체 기반의 언어, 원시 타입 외에는 모두 객체 타입.

    - **데이터 타입의 필요성**
        - 데이터 타입에 의한 메모리 공간의 확보와 참조

            → 자바스크립트 엔진은 데이터 타입에 따라 정해진 크기의 메모리 공간을 확보한다.

        - 데이터 타입에 의한 값의 해석

            → 모든 값은 메모리에 2진수, 비트의 나열로 저장되며, 데이터 타입에 따라 다르게 해석.

            (값 0100 0001 을 숫자로 해석하면 65, 문자열로 해석하면 'A')

    - **동적 타이핑**
        - 동적 타입 언어와 정적 타입 언어

        → C나 자바 같은 정적 타입 언어는 변수를 선언할 때 명시적으로 타입을 선언.

        → 자바스크립트는 변수 선언할 때 타입을 선언하지 않고, var, let, const 키워드만 사용.

        (자바스크립트는 값을 할당하는 시점에 변수의 타입이 동적으로 결정된다. 재할당으로 변수의 타입도 동적으로 변경 가능, 재할당이 자유로운만큼 주의해서 사용)

- **07장: 연산자**
    - **산술 연산자** : 피연산자를 계산해 새로운 숫자 값을 만듦. 산술 연산 불가능한 경우 NaN 반환.
        - 이항 산술 연산자 : 2개의 피연산자를 연산하여 숫자 값을 만듦. (+, -, *, /, %)
        - 단항 산술 연산자 : 1개의 피연산자를 연산하여 숫자 값을 만듦. (++, --, +, -)
        - 문자열 연결 연산자 : +연산에서 피연산자 중 하나 이상이 문자열인 경우 문자열 연결.

            (암묵적 타입 변환, 자세히는 9장에서)

    - **할당 연산자** : 우항의 평가 결과를 좌항 변수에 할당. (=, +=, -=, *=, /=, %=)

    - **비교 연산자** : 좌항과 우항의 피연산자를 비교하여 불리언 값으로 반환.
        - 동등/일치 비교 연산자 ( == 동등 비교, === 일치 비교, != 부동등 비교, !== 불일치비교)

        → 동등 비교(==)는 암묵적 타입 변환으로 타입 일치시키고 값을 비교함, 타입도 같고 값도 같은 경우 true를 반환하는 일치 비교(===)를 사용하는 것이 좋다.

        ```jsx
        // 일치 비교는 암묵적 타입 변환을 하지 않고 값을 비교
        5 === 5; // true
        5 === '5'; // false

        // NaN은 유일하게 자신과 일치하지 않는 값이므로, isNaN 사용
        NaN === NaN; // false 
        isNaN(NaN); // true
        isNaN(10); // false
        isNaN(1 + undefined); // true

        // 자바스크립트에서 양의 0과 음의 0 비교하면 모두 true
        0 === -0; // true
        0 == -0; // true

        // 좀 더 확실하게 비교 결과를 예측하려면 Object.is 메서드 활용
        Object.is(-0, +0); // false
        Object.is(NaN, NaN); // true
        ```

        - **대소 관계 비교 연산자** (>, <, >=, <=)

    - **삼항 조건 연산자** : 조건식 ? true 반환 값 : false 반환 값

        ```jsx
        // 삼항 조건 연산자 표현식
        var x = 2;
        var result = x % 2 ? '홀수' : '짝수'; // 결과 0은 false로 암묵적 타입 변환
        console.log(result); // 짝수
        ```

        → 조건문과 달리 값처럼 사용 가능. (조건문은 표현식 아닌 문, 삼항 연산자는 표현식인 문)

    - **논리 연산자** ( || , && , ! )

        ```jsx
        // or
        true || false; // true
        false || true; // true

        // and
        true && false; // false
        false && true; // false
        ```

        → or 연산자에서는 true가 우선이고, and 에서는 false가 우선순위에 있는 것 같다.

        ```jsx
        // not, 불리언 값 반환

        // 암묵적 타입 변환
        !0; // true
        !'Hello'; // false
        ```

    - **쉼표 연산자**: 왼쪽부터 차례대로 평가, 마지막 결과 반환 ( , )

    - **그룹 연산자** ( '( )' )

    - **typeof 연산자**

        ```jsx
        typeof '' // string
        typeof 1  // number
        typeof NaN // number
        typeof true // boolean
        typeof undefined // undefined
        typeof Symbol() // symbol
        typeof null // object
        typeof []   // object
        typeof {}   // object
        typeof new Date()  // object
        typeof /test/gi    // object
        typeof function(){}  // function

        // null 체크는 '===' 일치 연산자 활용
        var foo = null;
        foo === null; // true
        ```

        → null은 object를 반환하는데, 버그라고 한다. null 체크는 일치 연산자 활용

    - **지수 연산자** : 좌항이 밑, 우항이 지수로 거듭 제곱 (**). Math.pow()도 가능
